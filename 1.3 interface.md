# 为什么模型需要interface

## 一、先说结论（一句话版）

语言模型只会“说话”，不会“做事”。
Agent 的工作，是把“做事的能力”包装成模型能“点菜”的菜单。

## 二、为什么说“现实世界的能力”模型本来用不了？

以这个函数为例：
```python
def get_weather(city: str) -> str:
    return f"It's always sunny in {city}!"
```
**从 Python 的角度**

这是一个普通函数

只能被 程序员 调用

**从 GPT 的角度**

它 完全不知道这个函数存在

更不知道：

函数叫什么

需要什么参数

返回什么

👉 对模型来说，它是“现实世界的一部分”，是黑箱

## 三、语言模型真正“看得懂”的只有这三样

**语言模型只能处理：**

文本

结构化文本（JSON）

概率上的下一个 token


所以，如果你想让 GPT “用天气功能”，你必须把能力翻译成：
```python
{
  "name": "get_weather",
  "description": "Get weather for a given city",
  "parameters": {
    "city": "string"
  }
}
```

这不是给人看的，是 给模型看的。

## 四、这就是“接口（interface）”的本质
接口 ≠ 实现

你真正暴露给模型的不是：
```python
return f"It's always sunny in {city}!"
```

**而是：**

名字：get_weather

用途：查天气

参数：city（字符串

**我能做什么，不是我怎么做**

**这正是计算机科学里“接口”的定义。**

## 五、LangChain + @tool 在中间做了什么？

你写了：
```python
@tool
def get_weather(city: str) -> str:
    """Get weather for a given city."""
    ...
```

实际上发生了三件事：

**1️⃣ 把函数“翻译”成模型能读的 schema**

Tool: get_weather
Description: Get weather for a given city
Arguments: city (string)

**2️⃣ 在 prompt 里告诉模型：**

“你现在不只是会说话
你还能用这些工具”

**3️⃣ 当模型决定调用时：**

模型输出（不是执行）：
```python
{
  "name": "get_weather",
  "arguments": { "city": "sf" }
}
```

👉 模型只负责“决定”
👉 程序负责“执行”

## 六、一个非常重要的认知跃迁（请认真看）
**❌ 直觉误区**

“模型在调用函数”

**✅ 正确认知**

模型在“写一段调用指令”
系统在“照着执行”

这就是为什么 Agent 是安全的、可控的。

## 七、把这句话拆回你熟悉的形式

把现实世界的能力
→ 包成 Python 函数

把 Python 函数
→ 用 @tool 变成 schema

把 schema
→ 注入 prompt

让 GPT
→ 选择要不要用

LangChain
→ 真正去执行

## 八、换几个你马上就能理解的例子
🔹 查数据库
```python
@tool
def query_db(sql: str) -> list:
    """Run a SQL query"""
```

模型只需要知道：

有个工具

叫 query_db

能查数据

🔹 跑你自己的 ML 模型
```python
@tool
def predict(text: str) -> float:
    """Predict toxicity score"""
```

模型不知道你用的是 BERT 还是 XLM-R
它只知道：我可以用它

🔹 控制系统（危险但真实）
```python
@tool
def deploy(service: str):
    """Deploy a service to prod"""
```

所以才要权限、确认、审计。

## 九、为什么这“非常重要”

你现在学的不是某个 API，而是在学：

**如何把“世界”变成 LLM 的可操作对象**

这也是：

Agent

Tool Calling

Function Calling

LangGraph

AutoGPT

的共同底层思想。

## 十、最后一句话（总结）

Agent 不是“更聪明的模型”，
而是“会动手的模型 + 明确的接口边界”。