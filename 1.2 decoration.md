## 什么是decoration，例如@tool

### 一、先用一句人话解释

Python 装饰器 =
在“不改原函数代码”的情况下，给函数“加一层新能力”的语法

可以把它理解成：

给函数“贴插件 / 套壳 / 升级技能”

### 二、最直觉的类比（非常重要）

想象你有一个普通函数：
```python
def coffee():
    return "☕ 咖啡"
```

现在你想要：

记录它什么时候被调用

不改它内部代码

对所有类似函数都能用

👉 你给它 套一层外壳：
```python
def with_log(func):
    def wrapper():
        print("开始制作")
        result = func()
        print("制作完成")
        return result
    return wrapper
```

然后：

```python
coffee = with_log(coffee)
```

调用：
```python
coffee()
```

输出：

开始制作
制作完成


原函数完全没改，但能力升级了。

### 三、@装饰器 只是“语法糖”

上面的写法太丑了，所以 Python 给你一个更优雅的写法：
```python
@with_log
def coffee():
    return "☕ 咖啡"
```

👉 这两段代码是完全等价的：
```python
@with_log
def coffee(): ...
```

等价于：
```python
def coffee(): ...
coffee = with_log(coffee)
```

⚠️ 这是装饰器最关键的一点。

### 四、一个最小可运行例子
```python
def shout(func):
    def wrapper():
        return func().upper()
    return wrapper

@shout
def say_hi():
    return "hello"

print(say_hi())
```

输出：
```python
HELLO
```

发生了什么？

say_hi() 本来返回 "hello"

被 shout 装饰

实际执行的是 wrapper()

### 五、装饰器的“本质公式”（记住这个）

装饰器 = 接受函数 → 返回新函数

数学式：

decorator: f → f'

### 六、再看回@tool（关键连接点）
```python
@tool
def get_weather(city: str) -> str:
    ...
```


等价于：
```python
def get_weather(city: str) -> str:
    ...

get_weather = tool(get_weather)
```

也就是说：

tool 接收你的函数

读取：

函数名

参数类型

docstring

返回一个 “带 metadata 的 Tool 对象”

所以：

get_weather 已经不是普通函数了
而是一个 Agent 可用的工具描述 + 执行器

### 七、为什么装饰器特别适合 AI / Agent？

因为它：

✅ 不破坏原函数逻辑

✅ 可以自动提取 schema

✅ 可以统一管理能力

✅ 可以“声明式”暴露给模型

这和你现在做的事情 高度一致：

把现实世界的能力（查天气、查数据库、跑模型）
变成 语言模型可以理解和调用的接口

### 八、你现在看到 @xxx 可以立刻这样理解
| 写法              | 心里翻译成       |
| --------------- | ----------- |
| `@tool`         | “这个函数要给模型用” |
| `@dataclass`    | “帮我自动写构造函数” |
| `@staticmethod` | “这是类里的普通函数” |
| `@lru_cache`    | “帮我自动缓存结果”  |
